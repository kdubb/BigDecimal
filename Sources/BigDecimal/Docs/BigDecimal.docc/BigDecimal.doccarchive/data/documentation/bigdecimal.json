{"primaryContentSections":[{"kind":"content","content":[{"anchor":"overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Its functionality falls in the following categories:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Arithmetic: addition, subtraction, multiplication, division, remainder and"},{"type":"text","text":" "},{"type":"text","text":"exponentiation"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Constants: pi, zero, one, ten"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Functions: exp, log, log10, log2, pow, sqrt, root, factorial, gamma,"},{"type":"text","text":" "},{"type":"text","text":"trig + inverse, hyperbolic + inverse"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Rounding and scaling according to one of the rounding modes:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"awayFromZero"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"down"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"towardZero"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"toNearestOrEven"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"toNearestOrAwayFromZero"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"up"}]}]}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Comparison: the six standard operators "},{"type":"codeVoice","code":"=="},{"type":"text","text":", "},{"type":"codeVoice","code":"!="},{"type":"text","text":", "},{"type":"codeVoice","code":"<"},{"type":"text","text":", "},{"type":"codeVoice","code":"<="},{"type":"text","text":", "},{"type":"codeVoice","code":">"},{"type":"text","text":", and "},{"type":"codeVoice","code":">="}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Conversion: to String, to Double, to Decimal (the Swift Foundation type), to"},{"type":"text","text":" "},{"type":"text","text":"Decimal32 \/ Decimal64 \/ Decimal128"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Support for Decimal32, Decimal64 and Decimal128 values stored as UInt32,"},{"type":"text","text":" "},{"type":"text","text":"UInt64 and UInt128 values respectively, using Densely Packed Decimal (DPD)"},{"type":"text","text":" "},{"type":"text","text":"encoding or Binary Integer Decimal (BID) encoding"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Support for Decimal32, Decimal64 and Decimal128 mathematical operations"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Supports the IEEE 754 concepts of Infinity and NaN (Not a Number) with the"},{"type":"text","text":" "},{"type":"text","text":"latter having a "},{"type":"codeVoice","code":"signaling"},{"type":"text","text":" option."}]}]}]},{"anchor":"Dependencies","level":2,"type":"heading","text":"Dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"BigDecimal requires Swift from macOS 13.3+, iOS 16.4+, macCatalyst 16.4+,"},{"type":"text","text":" "},{"type":"text","text":"tvOS 16.4+, or watchOS 9.4+. It also requires that the "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" type be a 64-bit"},{"type":"text","text":" "},{"type":"text","text":"type."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The BigDecimal package depends on the BigInt and UInt128 packages."}]},{"type":"codeListing","syntax":null,"code":["dependencies: [","  .package(url: \"https:\/\/github.com\/mgriebling\/BigInt.git\", from: \"2.0.0\"),","  .package(url: \"https:\/\/github.com\/mgriebling\/UInt128.git\", from: \"3.0.0\")","]"]},{"anchor":"Usage","level":2,"type":"heading","text":"Usage"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In your project’s Package.swift file add a dependency like"}]},{"type":"codeListing","syntax":null,"code":["dependencies: [","  .package(url: \"https:\/\/github.com\/mgriebling\/BigDecimal.git\", from: \"2.0.0\"),","]"]},{"anchor":"Basics","level":2,"type":"heading","text":"Basics"},{"anchor":"Creating-BigDecimals","level":3,"type":"heading","text":"Creating BigDecimal’s"},{"type":"codeListing","syntax":"swift","code":["\/\/ From an integer","let x1 = BigDecimal(270) \/\/ = 270","let x2 = BigDecimal(270, -2)  \/\/ = 2.70","let x3 = BigDecimal(314159265, -8) \/\/ = 3.14159265","  ","\/\/ From a BInt","let x4 = BigDecimal(BInt(314159265), -8) \/\/ = 3.14159265","let x5 = BigDecimal(BInt(100), -3) \/\/ = 0.100","  ","\/\/ From a string literal","let rnd1 = Rounding(.halfEven, 2)","let x6 = BigDecimal(\"0.123\").round(rnd1) \/\/ = 0.12","let x7 = BigDecimal(\"3.14159265\") \/\/ = 3.14159265","  ","\/\/ From a double","let rnd2 = Rounding(.halfEven, 9)","let x8 = BigDecimal(0.1).round(rnd2)  \/\/ = 0.100000000","let x9 = BigDecimal(0.1) \/\/ = 0.1000000000000000055511151231257827021181583404541015625","let x10 = BigDecimal(3.14159265) \/\/ = 3.141592650000000208621031561051495373249053955078125","let x11 = BigDecimal(3.14159265).round(rnd2) \/\/ = 3.14159265","","\/\/ From Decimal32 \/ 64 \/ 128 encoded values","let x32 = BigDecimal(UInt32(0x223000f0), .dpd) \/\/ = 1.70","let x64 = BigDecimal(UInt64(0x22300000000000f0), .dpd) \/\/ = 1.70","let x128 = BigDecimal(UInt128(0x2207800000000000, 0x00000000000000f0), .dpd) \/\/ = 1.70"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because Double values cannot represent all decimal values exactly,"},{"type":"text","text":" "},{"type":"text","text":"one sees that BigDecimal(0.1) is not exactly equal to 1 \/ 10 as one might expect."},{"type":"text","text":" "},{"type":"text","text":"On the other hand, BigDecimal(“0.1”) is in fact exactly equal to 1 \/ 10."}]},{"anchor":"Converting-BigDecimals","level":3,"type":"heading","text":"Converting BigDecimal’s"},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal"},{"type":"text","text":" values can be converted to "},{"type":"codeVoice","code":"String"},{"type":"text","text":" values, "},{"type":"codeVoice","code":"Double"},{"type":"text","text":" values,"},{"type":"text","text":" "},{"type":"codeVoice","code":"Decimal"},{"type":"text","text":" (the Swift Foundation type) values, and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/Decimal32"},{"type":"text","text":", "},{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/Decimal64"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"text","text":"and "},{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/Decimal128"},{"type":"text","text":" values."}]},{"anchor":"To-String","level":4,"type":"heading","text":"To String"},{"type":"codeListing","syntax":"swift","code":["let x1 = BigDecimal(\"2.1\").pow(3)","print(x1.asString()) \/\/ = 9.261"]},{"anchor":"To-Double","level":4,"type":"heading","text":"To Double"},{"type":"codeListing","syntax":"swift","code":["let x2 = BigDecimal(\"2.1\").pow(3)","print(x2.asDouble()) \/\/ = 9.261"]},{"anchor":"To-Decimal-the-Swift-Foundation-type","level":4,"type":"heading","text":"To Decimal (the Swift Foundation type)"},{"type":"codeListing","syntax":"swift","code":["let x3 = BigDecimal(\"1.70\")","let xd: Decimal = x3.asDecimal()","print(xd) \/\/ = 1.70"]},{"anchor":"To-Decimal32--64--128","level":4,"type":"heading","text":"To Decimal32 \/ 64 \/ 128"},{"type":"codeListing","syntax":"swift","code":["let x4 = BigDecimal(\"1.70\")","let x32: UInt32 = x4.asDecimal32(.dpd)","let x64: UInt64 = x4.asDecimal64(.dpd)","let x128: UInt128 = x4.asDecimal128(.dpd)","print(String(x32, radix: 16))  \/\/ = 223000f0","print(String(x64, radix: 16))  \/\/ = 22300000000000f0","print(String(x128, radix: 16)) \/\/ = 220780000000000000000000000000f0"]},{"anchor":"Comparing-BigDecimals","level":3,"type":"heading","text":"Comparing BigDecimal’s"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The six standard operators == != < <= > >= are available to compare values."},{"type":"text","text":" "},{"type":"text","text":"The two operands may either be two "},{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal"},{"type":"text","text":"’s or a "},{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal"},{"type":"text","text":" and"},{"type":"text","text":" "},{"type":"text","text":"an integer. If neither of the operands is NaN, the operators perform as expected."},{"type":"text","text":" "},{"type":"text","text":"For example, -"},{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/BigDecimal\/infinity"},{"type":"text","text":" is less than any finite number which in"},{"type":"text","text":" "},{"type":"text","text":"turn is less than +"},{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/BigDecimal\/infinity"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Please see the section "},{"type":"emphasis","inlineContent":[{"type":"text","text":"About NaN’s"}]},{"type":"text","text":" for the rules governing comparison involving NaN’s."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The static function "},{"type":"codeVoice","code":"BigDecimal.maximum(x:y:)"},{"type":"text","text":" returns the non-NaN number if"},{"type":"text","text":" "},{"type":"text","text":"either x or y is NaN; otherwise it returns the larger of x and y."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The static function "},{"type":"codeVoice","code":"BigDecimal.minimum(x:y:)"},{"type":"text","text":" returns the non-NaN number if"},{"type":"text","text":" "},{"type":"text","text":"either x or y is NaN; otherwise it returns the smaller of x and y."}]},{"anchor":"Exact-Arithmetic","level":3,"type":"heading","text":"Exact Arithmetic"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The ‘+’, ‘-’, and ‘*’ operators always produce exact results. The ‘\/’ operator"},{"type":"text","text":" "},{"type":"text","text":"truncates the exact result to an integer."}]},{"type":"codeListing","syntax":"swift","code":["let a = BigDecimal(\"25.1\")","let b = BigDecimal(\"12.0041\")","","print(a + b) \/\/ = 37.1041","print(a - b) \/\/ = 13.0959","print(a * b) \/\/ = 301.30291","print(a \/ b) \/\/ = 2"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"quotientAndRemainder"}]},{"type":"text","text":" function produces an integer quotient and exact remainder"}]},{"type":"codeListing","syntax":"swift","code":["print(a.quotientAndRemainder(b)) \/\/ = (quotient: 2, remainder: 1.0918)"]},{"anchor":"Rounded-Arithmetic","level":3,"type":"heading","text":"Rounded Arithmetic"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Rounding is controlled by Rounding objects that contain a rounding mode and a"},{"type":"text","text":" "},{"type":"text","text":"precision, which is the number of digits in the rounded result."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The rounding modes are:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"awayFromZero - round away from 0"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"down - round towards -infinity"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"up - round towards +infinity"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"towardZero - round towards 0"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"toNearestOrEven - round to nearest, ties to even"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"toNearestOrAwayFromZero - round to nearest, ties away from 0"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"add"}]},{"type":"text","text":", "},{"type":"emphasis","inlineContent":[{"type":"text","text":"subtract"}]},{"type":"text","text":" and "},{"type":"emphasis","inlineContent":[{"type":"text","text":"multiply"}]},{"type":"text","text":" methods have a Rounding parameter that"},{"type":"text","text":" "},{"type":"text","text":"controls how the result is rounded."}]},{"anchor":"Examples","level":4,"type":"heading","text":"Examples"},{"type":"codeListing","syntax":"swift","code":["let a = BigDecimal(\"25.1E-2\")","let b = BigDecimal(\"12.0041E-3\")","let rnd = Rounding(.ceiling, 3)","\t","print(a + b) \/\/ = 0.2630041","print(a.add(b, rnd)) \/\/ = 0.264","print(a - b) \/\/ = 0.2389959","print(a.subtract(b, rnd)) \/\/ = 0.239","print(a * b) \/\/ = 0.0030130291","print(a.multiply(b, rnd)) \/\/ = 0.00302"]},{"anchor":"Precise-division","level":3,"type":"heading","text":"Precise division"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"emphasis","inlineContent":[{"type":"text","text":"divide"}]},{"type":"text","text":" method, that has an optional rounding parameter, performs division."},{"type":"text","text":" "},{"type":"text","text":"If the quotient has finite decimal expansion, the rounding parameter may or may not be present, it is used if it is there."},{"type":"text","text":" "},{"type":"text","text":"If the quotient has infinite decimal expansion, the rounding parameter must be present and is used to round the result."}]},{"anchor":"Examples","level":4,"type":"heading","text":"Examples"},{"type":"codeListing","syntax":"swift","code":["let x1 = BigDecimal(3)","let x2 = BigDecimal(48)","print(x1.divide(x2))  \/\/ = 0.0625","let rnd = Rounding(.ceiling, 2)","print(x1.divide(x2, rnd))  \/\/ = 0.063","\t","let x3 = BigDecimal(3)","let x4 = BigDecimal(49)","print(x3.divide(x4))       \/\/ = NaN because the quotient has infinite decimal expansion 0.06122448...","print(x3.divide(x4, rnd))  \/\/ = 0.062"]},{"anchor":"Data-Encoding","level":2,"type":"heading","text":"Data Encoding"},{"type":"paragraph","inlineContent":[{"type":"text","text":"BigDecimal’s can be encoded as Data objects (perhaps for long term storage) using the "},{"type":"emphasis","inlineContent":[{"type":"text","text":"asData"}]},{"type":"text","text":" method,"},{"type":"text","text":" "},{"type":"text","text":"and they can be regenerated from their Data encoding using the appropriate initializer."},{"type":"text","text":" "},{"type":"text","text":"The encoding rules are:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"The encoding contains nine or more bytes. The first eight bytes is a"},{"type":"text","text":" "},{"type":"text","text":"Big Endian encoding of the signed exponent."},{"type":"text","text":" "},{"type":"text","text":"The remaining bytes is a Big Endian encoding of the signed significand."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"NaN’s (and signaling NaNs) are encoded as a single byte = 0"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"positive infinity is encoded as a single byte = 1"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"negative infinity is encoded as a single byte = 2"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"negative zero is encoded as a single byte = 3"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It is also possible to encode BigDecimal’s using the "},{"type":"codeVoice","code":"JSONEncoder"},{"type":"text","text":" or as a"},{"type":"text","text":" "},{"type":"text","text":"property list using the "},{"type":"codeVoice","code":"PropertyListEncoder"},{"type":"text","text":" as in the second example."}]},{"anchor":"Examples","level":3,"type":"heading","text":"Examples"},{"type":"codeListing","syntax":"swift","code":["let x1 = BigDecimal(1000, 3) \/\/ = 1000000","print(Bytes(x1.asData()))   \/\/ = [0, 0, 0, 0, 0, 0, 0, 3, 3, 232]","","let x2 = BigDecimal(1000, -3) \/\/ = 1.000","print(Bytes(x2.asData()))   \/\/ = [255, 255, 255, 255, 255, 255, 255, 253, 3, 232]","","let x3 = BigDecimal(-1000, 3) \/\/ = -1000000","print(Bytes(x3.asData()))   \/\/ = [0, 0, 0, 0, 0, 0, 0, 3, 252, 24]","","let x4 = BigDecimal(-1000, -3) \/\/ = -1.000","print(Bytes(x4.asData()))   \/\/ = [255, 255, 255, 255, 255, 255, 255, 253, 252, 24]"]},{"type":"codeListing","syntax":"swift","code":["let encoder = JSONEncoder()","let x1 = BigDecimal(1000, 3) \/\/ = 1000000","if let encoded = try? encoder.encode(x1) {","    \/\/ save `encoded` data somewhere or","","    \/\/ extract the JSON string from the data","    if let json = String(data: encoded, encoding: .utf8) {","        print(json)","    }","}"]},{"anchor":"Decimal-Formats","level":2,"type":"heading","text":"Decimal Formats"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Decimal values can be represented not only as BigDecimal’s but also as Double values,"},{"type":"text","text":" "},{"type":"text","text":"Decimal (the Swift Foundation type) values, and Decimal32 \/ 64 \/ 128 values."},{"type":"text","text":" "},{"type":"text","text":"The strategy for working with other than BigDecimal values can be summarized as follows:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"convert the input values to BigDecimal’s using the appropriate initializer"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"compute the results"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"convert the results back to the desired output format using the appropriate conversion function"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As an example, suppose you must compute the average value of three values a, b and c which are encoded as Decimal32 values using Densely Packed Decimal (DPD) encoding."},{"type":"text","text":" "},{"type":"text","text":"The result x must likewise be a Decimal32 value encoded using DPD."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Input values","let a = UInt32(0x223e1117)  \/\/ = 7042.17 DPD encoded","let b = UInt32(0x22300901)  \/\/ =   22.01 DPD encoded","let c = UInt32(0xa230cc00)  \/\/ = -330.00 DPD encoded","\t","\/\/ Convert to BigDecimal's","let A = BigDecimal(a, .dpd)","let B = BigDecimal(b, .dpd)","let C = BigDecimal(c, .dpd)","\t","\/\/ Compute result","let X = (A + B + C).divide(3, Rounding.decimal32)","print(X)                    \/\/ = 2244.727","\t","\/\/ Convert result back to Decimal32","let x = X.asDecimal32(.dpd)","print(String(x, radix: 16)) \/\/ = 2a2513a7 (= 2244.727 DPD encoded)"]},{"anchor":"About-Infinities","level":2,"type":"heading","text":"About Infinities"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The constants "},{"type":"codeVoice","code":"BigDecimal.infinity"},{"type":"text","text":" and "},{"type":"codeVoice","code":"-BigDecimal.infinity"},{"type":"text","text":" represent"},{"type":"text","text":" "},{"type":"text","text":"+Infinity and -Infinity respectively."},{"type":"text","text":" "},{"type":"codeVoice","code":"-infinity"},{"type":"text","text":" compares less than every finite number,"},{"type":"text","text":" "},{"type":"text","text":"and every finite number compares less than "},{"type":"codeVoice","code":"infinity"},{"type":"text","text":". Arithmetic operations"},{"type":"text","text":" "},{"type":"text","text":"involving infinite values is illustrated by the examples below:"}]},{"type":"codeListing","syntax":"swift","code":["let InfP = BigDecimal.infinity \/\/ Just to save some writing","let InfN = -BigDecimal.infinity","","print(InfP + 3)     \/\/ +Infinity","print(InfN + 3)     \/\/ -Infinity","print(InfP + InfP)  \/\/ +Infinity","print(InfP - InfP)  \/\/ NaN","print(InfP * 3)     \/\/ +Infinity","print(InfP * InfP)  \/\/ +Infinity","print(InfP * InfN)  \/\/ -Infinity","print(InfP * 0)     \/\/ NaN","print(InfP \/ 3)     \/\/ +Infinity","print(InfP \/ 0)     \/\/ +Infinity","print(1 \/ InfP)     \/\/ 0","print(1 \/ InfN)     \/\/ 0","print(InfP \/ InfP)  \/\/ NaN","print(InfP < InfP)  \/\/ false","print(InfP == InfP) \/\/ true","print(InfP != InfP) \/\/ false","print(InfP > InfP)  \/\/ false","print(Rounding.decimal32.round(InfP))    \/\/ +Infinity","print(InfP.scale(4))    \/\/ +Infinity","print(InfP.scale(-4))   \/\/ +Infinity","print(InfP.withExponent(10, .up))   \/\/ NaN"]},{"anchor":"About-NaNs","level":2,"type":"heading","text":"About NaN’s"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The IEEE 754 standard specifies two NaN’s, a quiet NaN (qNaN) and a signaling NaN (sNaN)."},{"type":"text","text":" "},{"type":"text","text":"The constant "},{"type":"emphasis","inlineContent":[{"type":"text","text":"BigDecimal.NaN"}]},{"type":"text","text":" corresponds to the quiet NaN and"},{"type":"text","text":" "},{"type":"codeVoice","code":"BigDecimal.signalingNan"},{"type":"text","text":" to the signaling NaN."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Arithmetic operations where one or more input is NaN, return NaN as result."},{"type":"text","text":" "},{"type":"text","text":"Comparing NaN values is illustrated by the example below:"}]},{"type":"codeListing","syntax":"swift","code":["let NaN = BigDecimal.NaN \/\/ Just to save some writing","\t","print(3 < NaN)      \/\/ false","print(NaN < 3)      \/\/ false","print(NaN < NaN)    \/\/ false","print(3 <= NaN)     \/\/ false","print(NaN <= 3)     \/\/ false","print(NaN <= NaN)   \/\/ false","print(3 > NaN)      \/\/ false","print(NaN > 3)      \/\/ false","print(NaN > NaN)    \/\/ false","print(3 >= NaN)     \/\/ false","print(NaN >= 3)     \/\/ false","print(NaN >= NaN)   \/\/ false","print(3 == NaN)     \/\/ false","print(NaN == 3)     \/\/ false","print(NaN == NaN)   \/\/ false","print(3 != NaN)     \/\/ true","print(NaN != 3)     \/\/ true","print(NaN != NaN)   \/\/ true !!!"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Because NaN != NaN is true, sorting a collection of BigDecimal’s doesn’t"},{"type":"text","text":" "},{"type":"text","text":"work if the collection contains one or more NaN’s. This is so, even if"},{"type":"text","text":" "},{"type":"text","text":"BigDecimal conforms to the Comparable protocol. Note: It is possible to"},{"type":"text","text":" "},{"type":"text","text":"sort values including NaNs using the "},{"type":"codeVoice","code":"isTotallyOrdered(belowOrEqualTo:)"},{"type":"text","text":" "},{"type":"text","text":"method."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The following example uses "},{"type":"codeVoice","code":"isTotallyOrdered(belowOrEqualTo:)"},{"type":"text","text":" to sort an"},{"type":"text","text":" "},{"type":"text","text":"array of floating-point values, including some that are NaN:"}]},{"type":"codeListing","syntax":"swift","code":["var numbers = [2.5, 21.25, 3.0, .nan, -9.5]","numbers.sort { !$1.isTotallyOrdered(belowOrEqualTo: $0) }","print(numbers)","\/\/ Prints \"[-9.5, 2.5, 3.0, 21.25, nan]\""]},{"type":"paragraph","inlineContent":[{"type":"text","text":"There is a static boolean variable "},{"type":"emphasis","inlineContent":[{"type":"text","text":"BigDecimal.NaNFlag"}]},{"type":"text","text":" which is set to"},{"type":"text","text":" "},{"type":"emphasis","inlineContent":[{"type":"text","text":"true"}]},{"type":"text","text":" whenever a NaN value is generated. It can be set to "},{"type":"emphasis","inlineContent":[{"type":"text","text":"false"}]},{"type":"text","text":" by"},{"type":"text","text":" "},{"type":"text","text":"application code. Therefore, to check if a sequence of code generates NaN,"},{"type":"text","text":" "},{"type":"text","text":"set NaNFlag to "},{"type":"emphasis","inlineContent":[{"type":"text","text":"false"}]},{"type":"text","text":" before the code and check it after the code. Since"},{"type":"text","text":" "},{"type":"text","text":"a BigDecimal has a stored property "},{"type":"emphasis","inlineContent":[{"type":"text","text":"isNaN"}]},{"type":"text","text":", it is of course also possible to"},{"type":"text","text":" "},{"type":"text","text":"check for a NaN value at any time."}]},{"anchor":"References","level":2,"type":"heading","text":"References"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Algorithms from the following books and papers have been used in the implementation."},{"type":"text","text":" "},{"type":"text","text":"There are references in the source code where appropriate."}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"[GRANLUND] - Moller and Granlund: Improved Division by Invariant Integers, 2011"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"[IEEE] - IEEE Standard for Floating-Point Arithmetic, 2019"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"[KNUTH] - Donald E. Knuth: Seminumerical Algorithms, Addison-Wesley 1971"}]}]}]},{"anchor":"Acknowledgement","level":2,"type":"heading","text":"Acknowledgement"},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Much of the original "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/leif-ibsen\/BigDecimal.git"},{"type":"text","text":" (pre-V2) was created by Leif Ibsen."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Some unit test cases come from the "},{"type":"reference","isActive":true,"identifier":"http:\/\/speleotrove.com\/decimal"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Additional unit test cases and some algorithms are from the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/www.intel.com\/content\/www\/us\/en\/developer\/articles\/tool\/intel-decimal-floating-point-math-library.html"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Floating point math functions are translated to Swift from the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/eobermuhlner\/big-math"},{"type":"text","text":" implementation by Eric Obermühlner."}]}]}]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/bigdecimal"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/BigDecimal\/documentation\/BigDecimal","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"The BigDecimal package provides arbitrary-precision (with an adjustable upper"},{"type":"text","text":" "},{"type":"text","text":"limit for performance) and fixed-precision decimal arithmetic in Swift."}],"kind":"symbol","metadata":{"roleHeading":"Framework","externalID":"BigDecimal","title":"BigDecimal","symbolKind":"module","role":"collection","modules":[{"name":"BigDecimal"}]},"hierarchy":{"paths":[[]]},"topicSections":[{"title":"Protocols","identifiers":["doc:\/\/BigDecimal\/documentation\/BigDecimal\/DecimalFloatingPoint","doc:\/\/BigDecimal\/documentation\/BigDecimal\/PowerIterator","doc:\/\/BigDecimal\/documentation\/BigDecimal\/SeriesCalculator"]},{"title":"Structures","identifiers":["doc:\/\/BigDecimal\/documentation\/BigDecimal\/AsinCalculator","doc:\/\/BigDecimal\/documentation\/BigDecimal\/BigDecimal","doc:\/\/BigDecimal\/documentation\/BigDecimal\/CosCalculator","doc:\/\/BigDecimal\/documentation\/BigDecimal\/CoshCalculator","doc:\/\/BigDecimal\/documentation\/BigDecimal\/Decimal128","doc:\/\/BigDecimal\/documentation\/BigDecimal\/Decimal32","doc:\/\/BigDecimal\/documentation\/BigDecimal\/Decimal64","doc:\/\/BigDecimal\/documentation\/BigDecimal\/ExpCalculator","doc:\/\/BigDecimal\/documentation\/BigDecimal\/PowerNIterator","doc:\/\/BigDecimal\/documentation\/BigDecimal\/PowerTwoNIterator","doc:\/\/BigDecimal\/documentation\/BigDecimal\/PowerTwoNPlusOneIterator","doc:\/\/BigDecimal\/documentation\/BigDecimal\/Rounding","doc:\/\/BigDecimal\/documentation\/BigDecimal\/SinCalculator","doc:\/\/BigDecimal\/documentation\/BigDecimal\/SinhCalculator","doc:\/\/BigDecimal\/documentation\/BigDecimal\/Status"]},{"title":"Type Aliases","identifiers":["doc:\/\/BigDecimal\/documentation\/BigDecimal\/IntRange","doc:\/\/BigDecimal\/documentation\/BigDecimal\/RoundingRule","doc:\/\/BigDecimal\/documentation\/BigDecimal\/Sign"]}],"references":{"doc://BigDecimal/documentation/BigDecimal/BigDecimal":{"role":"symbol","title":"BigDecimal","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"BigDecimal"}],"abstract":[{"type":"text","text":"A signed decimal value of unbounded precision (actually there is a"},{"type":"text","text":" "},{"type":"text","text":"practical limit defined by "},{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/BigDecimal\/maxDigits"},{"type":"text","text":" of 200 that the user can change)."},{"type":"text","text":" "},{"type":"text","text":"A "},{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal"},{"type":"text","text":" value is represented as a signed "},{"type":"codeVoice","code":"BInt"},{"type":"text","text":" significand"},{"type":"text","text":" "},{"type":"text","text":"and a signed "},{"type":"codeVoice","code":"Int"},{"type":"text","text":" exponent that is limited to ten digits."},{"type":"text","text":" "},{"type":"text","text":"The value of a Self is "},{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/BigDecimal\/digits"},{"type":"text","text":" * 10^"},{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/BigDecimal\/exponent"},{"type":"text","text":"."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/BigDecimal","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"BigDecimal"}],"url":"\/documentation\/bigdecimal\/bigdecimal"},"doc://BigDecimal/documentation/BigDecimal/Sign":{"role":"symbol","title":"Sign","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"Sign"}],"abstract":[],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/Sign","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Sign"}],"url":"\/documentation\/bigdecimal\/sign"},"doc://BigDecimal/documentation/BigDecimal/BigDecimal/infinity":{"role":"symbol","title":"infinity","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"infinity"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"BigDecimal","preciseIdentifier":"s:10BigDecimalAAV"}],"abstract":[{"type":"text","text":"BigDecimal(‘Infinity’)"}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/BigDecimal\/infinity","kind":"symbol","type":"topic","url":"\/documentation\/bigdecimal\/bigdecimal\/infinity"},"doc://BigDecimal/documentation/BigDecimal/Decimal32":{"role":"symbol","title":"Decimal32","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Decimal32"}],"abstract":[{"type":"text","text":"Implementation of the 32-bit Decimal32 floating-point operations from"},{"type":"text","text":" "},{"type":"text","text":"IEEE STD 754-2019 for Floating-Point Arithmetic."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/Decimal32","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Decimal32"}],"url":"\/documentation\/bigdecimal\/decimal32"},"doc://BigDecimal/documentation/BigDecimal/Decimal128":{"role":"symbol","title":"Decimal128","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Decimal128"}],"abstract":[{"type":"text","text":"Implementation of the 128-bit Decimal128 floating-point operations from"},{"type":"text","text":" "},{"type":"text","text":"IEEE STD 754-2019 for Floating-Point Arithmetic."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/Decimal128","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Decimal128"}],"url":"\/documentation\/bigdecimal\/decimal128"},"doc://BigDecimal/documentation/BigDecimal/PowerIterator":{"role":"symbol","title":"PowerIterator","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"PowerIterator"}],"abstract":[],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/PowerIterator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"PowerIterator"}],"url":"\/documentation\/bigdecimal\/poweriterator"},"doc://BigDecimal/documentation/BigDecimal/PowerTwoNIterator":{"role":"symbol","title":"PowerTwoNIterator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"PowerTwoNIterator"}],"abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/PowerIterator"},{"type":"text","text":" to calculate the 2*n term."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/PowerTwoNIterator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"PowerTwoNIterator"}],"url":"\/documentation\/bigdecimal\/powertwoniterator"},"doc://BigDecimal/documentation/BigDecimal/RoundingRule":{"role":"symbol","title":"RoundingRule","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"RoundingRule"}],"abstract":[{"type":"text","text":"The rounding modes"}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/RoundingRule","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"RoundingRule"}],"url":"\/documentation\/bigdecimal\/roundingrule"},"doc://BigDecimal/documentation/BigDecimal/BigDecimal/maxDigits":{"role":"symbol","title":"maxDigits","fragments":[{"kind":"keyword","text":"static"},{"kind":"text","text":" "},{"kind":"keyword","text":"let"},{"kind":"text","text":" "},{"kind":"identifier","text":"maxDigits"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"}],"abstract":[],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/BigDecimal\/maxDigits","kind":"symbol","type":"topic","url":"\/documentation\/bigdecimal\/bigdecimal\/maxdigits"},"doc://BigDecimal/documentation/BigDecimal/Rounding":{"role":"symbol","title":"Rounding","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Rounding"}],"abstract":[{"type":"text","text":"BigDecimal rounding object containing a rounding mode and a precision"},{"type":"text","text":" "},{"type":"text","text":"which is the number of digits in the rounded result"}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/Rounding","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Rounding"}],"url":"\/documentation\/bigdecimal\/rounding"},"doc://BigDecimal/documentation/BigDecimal/Decimal64":{"role":"symbol","title":"Decimal64","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Decimal64"}],"abstract":[{"type":"text","text":"Implementation of the 64-bit Decimal64 floating-point operations from"},{"type":"text","text":" "},{"type":"text","text":"IEEE STD 754-2019 for Floating-Point Arithmetic."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/Decimal64","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Decimal64"}],"url":"\/documentation\/bigdecimal\/decimal64"},"http://speleotrove.com/decimal":{"title":"General Decimal Arithmetic","titleInlineContent":[{"type":"text","text":"General Decimal Arithmetic"}],"type":"link","identifier":"http:\/\/speleotrove.com\/decimal","url":"http:\/\/speleotrove.com\/decimal"},"doc://BigDecimal/documentation/BigDecimal/BigDecimal/exponent":{"role":"symbol","title":"exponent","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"exponent"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"Int","preciseIdentifier":"s:Si"}],"abstract":[{"type":"text","text":"The signed exponent - the value of "},{"type":"emphasis","inlineContent":[{"type":"text","text":"self"}]},{"type":"text","text":" is "},{"type":"emphasis","inlineContent":[{"type":"text","text":"self.significand"}]},{"type":"text","text":" *"},{"type":"text","text":" "},{"type":"text","text":"10^"},{"type":"emphasis","inlineContent":[{"type":"text","text":"self.exponent"}]}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/BigDecimal\/exponent","kind":"symbol","type":"topic","url":"\/documentation\/bigdecimal\/bigdecimal\/exponent"},"doc://BigDecimal/documentation/BigDecimal/IntRange":{"role":"symbol","title":"IntRange","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"IntRange"}],"abstract":[],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/IntRange","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IntRange"}],"url":"\/documentation\/bigdecimal\/intrange"},"doc://BigDecimal/documentation/BigDecimal/DecimalFloatingPoint":{"role":"symbol","title":"DecimalFloatingPoint","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"DecimalFloatingPoint"}],"abstract":[{"type":"text","text":"A radix-10 (decimal) floating-point type."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/DecimalFloatingPoint","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"DecimalFloatingPoint"}],"url":"\/documentation\/bigdecimal\/decimalfloatingpoint"},"doc://BigDecimal/documentation/BigDecimal/PowerNIterator":{"role":"symbol","title":"PowerNIterator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"PowerNIterator"}],"abstract":[],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/PowerNIterator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"PowerNIterator"}],"url":"\/documentation\/bigdecimal\/powerniterator"},"https://www.intel.com/content/www/us/en/developer/articles/tool/intel-decimal-floating-point-math-library.html":{"title":"Intel C Decimal Floating-Point Math library","titleInlineContent":[{"type":"text","text":"Intel C Decimal Floating-Point Math library"}],"type":"link","identifier":"https:\/\/www.intel.com\/content\/www\/us\/en\/developer\/articles\/tool\/intel-decimal-floating-point-math-library.html","url":"https:\/\/www.intel.com\/content\/www\/us\/en\/developer\/articles\/tool\/intel-decimal-floating-point-math-library.html"},"doc://BigDecimal/documentation/BigDecimal/SinhCalculator":{"role":"symbol","title":"SinhCalculator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SinhCalculator"}],"abstract":[{"type":"text","text":"Calculates hyperbolic sine using the Maclaurin\/Taylor series."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/SinhCalculator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SinhCalculator"}],"url":"\/documentation\/bigdecimal\/sinhcalculator"},"doc://BigDecimal/documentation/BigDecimal/Status":{"role":"symbol","title":"Status","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Status"}],"abstract":[],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/Status","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Status"}],"url":"\/documentation\/bigdecimal\/status"},"https://github.com/leif-ibsen/BigDecimal.git":{"title":"BigDecimal","titleInlineContent":[{"type":"text","text":"BigDecimal"}],"type":"link","identifier":"https:\/\/github.com\/leif-ibsen\/BigDecimal.git","url":"https:\/\/github.com\/leif-ibsen\/BigDecimal.git"},"https://github.com/eobermuhlner/big-math":{"title":"Java BigDecimalMath","titleInlineContent":[{"type":"text","text":"Java BigDecimalMath"}],"type":"link","identifier":"https:\/\/github.com\/eobermuhlner\/big-math","url":"https:\/\/github.com\/eobermuhlner\/big-math"},"doc://BigDecimal/documentation/BigDecimal/PowerTwoNPlusOneIterator":{"role":"symbol","title":"PowerTwoNPlusOneIterator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"PowerTwoNPlusOneIterator"}],"abstract":[{"type":"reference","isActive":true,"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/PowerIterator"},{"type":"text","text":" to calculate the 2*n+1 term."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/PowerTwoNPlusOneIterator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"PowerTwoNPlusOneIterator"}],"url":"\/documentation\/bigdecimal\/powertwonplusoneiterator"},"doc://BigDecimal/documentation/BigDecimal":{"role":"collection","title":"BigDecimal","abstract":[{"type":"text","text":"The BigDecimal package provides arbitrary-precision (with an adjustable upper"},{"type":"text","text":" "},{"type":"text","text":"limit for performance) and fixed-precision decimal arithmetic in Swift."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal","kind":"symbol","type":"topic","url":"\/documentation\/bigdecimal"},"doc://BigDecimal/documentation/BigDecimal/SinCalculator":{"role":"symbol","title":"SinCalculator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"SinCalculator"}],"abstract":[{"type":"text","text":"Calculates sine using the Maclaurin\/Taylor series."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/SinCalculator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SinCalculator"}],"url":"\/documentation\/bigdecimal\/sincalculator"},"doc://BigDecimal/documentation/BigDecimal/CosCalculator":{"role":"symbol","title":"CosCalculator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CosCalculator"}],"abstract":[{"type":"text","text":"Calculates cosine using the Maclaurin\/Taylor series."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/CosCalculator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CosCalculator"}],"url":"\/documentation\/bigdecimal\/coscalculator"},"doc://BigDecimal/documentation/BigDecimal/CoshCalculator":{"role":"symbol","title":"CoshCalculator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"CoshCalculator"}],"abstract":[{"type":"text","text":"Calculates hyperbolic cosine using the Maclaurin\/Taylor series."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/CoshCalculator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"CoshCalculator"}],"url":"\/documentation\/bigdecimal\/coshcalculator"},"doc://BigDecimal/documentation/BigDecimal/AsinCalculator":{"role":"symbol","title":"AsinCalculator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"AsinCalculator"}],"abstract":[{"type":"text","text":"Calculates arcsine using the Maclaurin\/Taylor series."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/AsinCalculator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"AsinCalculator"}],"url":"\/documentation\/bigdecimal\/asincalculator"},"doc://BigDecimal/documentation/BigDecimal/SeriesCalculator":{"role":"symbol","title":"SeriesCalculator","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"SeriesCalculator"}],"abstract":[],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/SeriesCalculator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"SeriesCalculator"}],"url":"\/documentation\/bigdecimal\/seriescalculator"},"doc://BigDecimal/documentation/BigDecimal/ExpCalculator":{"role":"symbol","title":"ExpCalculator","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"ExpCalculator"}],"abstract":[{"type":"text","text":"Calculates exp using the Maclaurin\/Taylor series."}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/ExpCalculator","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ExpCalculator"}],"url":"\/documentation\/bigdecimal\/expcalculator"},"doc://BigDecimal/documentation/BigDecimal/BigDecimal/digits":{"role":"symbol","title":"digits","fragments":[{"kind":"keyword","text":"var"},{"kind":"text","text":" "},{"kind":"identifier","text":"digits"},{"kind":"text","text":": "},{"kind":"typeIdentifier","text":"BInt","preciseIdentifier":"s:6BigInt4BIntV"}],"abstract":[{"type":"text","text":"The signed BInt significand"}],"identifier":"doc:\/\/BigDecimal\/documentation\/BigDecimal\/BigDecimal\/digits","kind":"symbol","type":"topic","url":"\/documentation\/bigdecimal\/bigdecimal\/digits"}}}